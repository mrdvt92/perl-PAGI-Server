[
  {
    "category": "functional",
    "description": "Basic HTTP response - 01-hello-http app returns 200 OK with plain text body",
    "steps": [
      "Step 1: Start the PAGI server with examples/01-hello-http/app.pl",
      "Step 2: Send a GET request using curl to http://localhost:5000/",
      "Step 3: Verify response status is 200 OK",
      "Step 4: Verify Content-Type header is text/plain",
      "Step 5: Verify response body contains 'Hello from PAGI'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "HTTP scope contains all required keys per PAGI specification",
    "steps": [
      "Step 1: Start the PAGI server with a test app that logs the scope",
      "Step 2: Send a GET request to http://localhost:5000/test/path?query=value",
      "Step 3: Verify scope contains 'type' => 'http'",
      "Step 4: Verify scope contains 'pagi' hash with version info",
      "Step 5: Verify scope contains 'http_version' => '1.1'",
      "Step 6: Verify scope contains 'method' => 'GET'",
      "Step 7: Verify scope contains 'scheme' => 'http'",
      "Step 8: Verify scope contains 'path' => '/test/path' (decoded)",
      "Step 9: Verify scope contains 'query_string' => 'query=value'",
      "Step 10: Verify scope contains 'headers' as arrayref of [name, value] pairs",
      "Step 11: Verify scope contains 'client' with [host, port]",
      "Step 12: Verify scope contains 'server' with [host, port]"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "App exceptions result in 500 Internal Server Error response",
    "steps": [
      "Step 1: Start the PAGI server with an app that throws an exception",
      "Step 2: Send a GET request to the server",
      "Step 3: Verify response status is 500",
      "Step 4: Verify connection is closed cleanly after error response"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Streaming response with multiple chunks - 02-streaming-response app",
    "steps": [
      "Step 1: Start the PAGI server with examples/02-streaming-response/app.pl",
      "Step 2: Send a GET request to http://localhost:5000/",
      "Step 3: Verify response uses chunked Transfer-Encoding",
      "Step 4: Verify response body contains 'Chunk 1', 'Chunk 2', 'Chunk 3' in order",
      "Step 5: Verify response completes successfully"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "HTTP trailers are transmitted after streaming body",
    "steps": [
      "Step 1: Start the PAGI server with examples/02-streaming-response/app.pl",
      "Step 2: Send a GET request with TE: trailers header",
      "Step 3: Verify Trailer header is present in response",
      "Step 4: Verify x-stream-complete: 1 trailer appears after body"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Client disconnect detection stops the streaming app",
    "steps": [
      "Step 1: Start the PAGI server with examples/02-streaming-response/app.pl",
      "Step 2: Open a connection and start receiving response",
      "Step 3: Disconnect the client before all chunks are received",
      "Step 4: Verify http.disconnect event is emitted to the app",
      "Step 5: Verify app stops streaming and cleans up resources"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Request body handling - 03-request-body app echoes POST body",
    "steps": [
      "Step 1: Start the PAGI server with examples/03-request-body/app.pl",
      "Step 2: Send a POST request with body 'Hello World'",
      "Step 3: Verify response status is 200",
      "Step 4: Verify response body contains 'You sent: Hello World'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "GET request without body receives empty body event",
    "steps": [
      "Step 1: Start the PAGI server with examples/03-request-body/app.pl",
      "Step 2: Send a GET request without body",
      "Step 3: Verify response contains 'No body provided'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Large request body arrives as multiple http.request events",
    "steps": [
      "Step 1: Start the PAGI server with examples/03-request-body/app.pl",
      "Step 2: Send a POST request with a large body (> 64KB)",
      "Step 3: Verify the complete body is received and echoed correctly",
      "Step 4: Verify intermediate events have more => 1, final has more => 0"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Chunked Transfer-Encoding on request body works correctly",
    "steps": [
      "Step 1: Start the PAGI server with examples/03-request-body/app.pl",
      "Step 2: Send a POST request with chunked Transfer-Encoding",
      "Step 3: Verify the body is de-chunked before passing to app",
      "Step 4: Verify response echoes the complete body"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "WebSocket echo - 04-websocket-echo app echoes messages",
    "steps": [
      "Step 1: Start the PAGI server with examples/04-websocket-echo/app.pl",
      "Step 2: Open a WebSocket connection to ws://localhost:5000/",
      "Step 3: Verify handshake completes with correct Sec-WebSocket-Accept",
      "Step 4: Send a text message 'Hello'",
      "Step 5: Verify server responds with 'echo: Hello'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "WebSocket binary frames are echoed correctly",
    "steps": [
      "Step 1: Start the PAGI server with examples/04-websocket-echo/app.pl",
      "Step 2: Open a WebSocket connection",
      "Step 3: Send a binary frame with bytes",
      "Step 4: Verify server echoes the binary frame unchanged"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "WebSocket clean close handshake works",
    "steps": [
      "Step 1: Start the PAGI server with examples/04-websocket-echo/app.pl",
      "Step 2: Open a WebSocket connection and exchange messages",
      "Step 3: Send a close frame to the server",
      "Step 4: Verify server responds with close frame",
      "Step 5: Verify websocket.disconnect event is emitted to app"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "WebSocket subprotocol negotiation works",
    "steps": [
      "Step 1: Create a test app that accepts a specific subprotocol",
      "Step 2: Open WebSocket with Sec-WebSocket-Protocol: echo, chat",
      "Step 3: Verify server responds with negotiated subprotocol in websocket.accept",
      "Step 4: Verify Sec-WebSocket-Protocol in 101 response matches"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "WebSocket PING frames receive automatic PONG response",
    "steps": [
      "Step 1: Start the PAGI server with examples/04-websocket-echo/app.pl",
      "Step 2: Open a WebSocket connection",
      "Step 3: Send a PING frame",
      "Step 4: Verify server responds with PONG frame",
      "Step 5: Verify PING/PONG is transparent to the application"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "SSE broadcaster - 05-sse-broadcaster app streams events",
    "steps": [
      "Step 1: Start the PAGI server with examples/05-sse-broadcaster/app.pl",
      "Step 2: Send GET request with Accept: text/event-stream",
      "Step 3: Verify response Content-Type is text/event-stream",
      "Step 4: Verify event: tick with data: 1 is received",
      "Step 5: Verify event: tick with data: 2 is received",
      "Step 6: Verify event: done with data: finished is received"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "SSE multi-line data fields formatted correctly",
    "steps": [
      "Step 1: Create a test app that sends multi-line SSE data",
      "Step 2: Connect with Accept: text/event-stream",
      "Step 3: Verify multi-line data is split into multiple data: lines",
      "Step 4: Verify EventSource API reconstructs multi-line data"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "SSE disconnect detection emits sse.disconnect",
    "steps": [
      "Step 1: Start the PAGI server with examples/05-sse-broadcaster/app.pl",
      "Step 2: Connect and start receiving events",
      "Step 3: Disconnect the client mid-stream",
      "Step 4: Verify sse.disconnect event is emitted to app"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Lifespan startup initializes shared state - 06-lifespan-state app",
    "steps": [
      "Step 1: Start the PAGI server with examples/06-lifespan-state/app.pl",
      "Step 2: Verify server waits for lifespan.startup.complete before accepting connections",
      "Step 3: Send a GET request to the server",
      "Step 4: Verify response contains 'Hello from lifespan via shared state'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Lifespan startup failure prevents connection acceptance",
    "steps": [
      "Step 1: Create a test app that sends lifespan.startup.failed",
      "Step 2: Start the server with this app",
      "Step 3: Verify server logs error and exits",
      "Step 4: Verify no connections are accepted"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Graceful shutdown waits for lifespan.shutdown.complete",
    "steps": [
      "Step 1: Start the PAGI server with examples/06-lifespan-state/app.pl",
      "Step 2: Send SIGTERM to the server process",
      "Step 3: Verify lifespan.shutdown event is emitted to app",
      "Step 4: Verify server waits for lifespan.shutdown.complete",
      "Step 5: Verify server exits cleanly after shutdown completes"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Fullflush extension forces immediate TCP buffer flush - 07-extension-fullflush app",
    "steps": [
      "Step 1: Start the PAGI server with examples/07-extension-fullflush/app.pl with fullflush extension enabled",
      "Step 2: Send a GET request to the server",
      "Step 3: Verify each chunk is received immediately after http.fullflush",
      "Step 4: Verify response body contains 'Line 1', 'Line 2', 'Line 3'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Extensions are advertised in scope.extensions",
    "steps": [
      "Step 1: Start the PAGI server with fullflush extension enabled",
      "Step 2: Create a test app that checks scope.extensions",
      "Step 3: Verify scope.extensions.fullflush exists when enabled",
      "Step 4: Verify scope.extensions.fullflush is absent when not enabled"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Unknown extension events are rejected appropriately",
    "steps": [
      "Step 1: Start the PAGI server without fullflush extension",
      "Step 2: Create a test app that sends http.fullflush event",
      "Step 3: Verify the event is rejected or causes an error"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "TLS connection populates scope.extensions.tls - 08-tls-introspection app",
    "steps": [
      "Step 1: Start the PAGI server with TLS enabled",
      "Step 2: Send HTTPS request with examples/08-tls-introspection/app.pl",
      "Step 3: Verify response contains TLS info with tls_version",
      "Step 4: Verify response contains cipher_suite",
      "Step 5: Verify scheme is 'https'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Non-TLS connections have no tls extension",
    "steps": [
      "Step 1: Start the PAGI server without TLS",
      "Step 2: Run examples/08-tls-introspection/app.pl",
      "Step 3: Send HTTP request",
      "Step 4: Verify response says 'Connection is not using TLS'",
      "Step 5: Verify scheme is 'http'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "TLS client certificates are captured when provided",
    "steps": [
      "Step 1: Start PAGI server with TLS and client cert verification",
      "Step 2: Send HTTPS request with client certificate",
      "Step 3: Verify scope.extensions.tls.client_cert_chain is populated",
      "Step 4: Verify scope.extensions.tls.client_cert_name contains DN"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "PSGI bridge runs legacy PSGI apps - 09-psgi-bridge app",
    "steps": [
      "Step 1: Start the PAGI server with examples/09-psgi-bridge/app.pl",
      "Step 2: Send a GET request to the server",
      "Step 3: Verify response status is 200",
      "Step 4: Verify response body contains 'PSGI says hi'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "PSGI bridge passes request body to psgi.input",
    "steps": [
      "Step 1: Start the PAGI server with examples/09-psgi-bridge/app.pl",
      "Step 2: Send a POST request with body 'test data'",
      "Step 3: Verify response body contains 'Body: test data'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "PSGI env contains all required keys",
    "steps": [
      "Step 1: Create a PSGI app that dumps the entire %env",
      "Step 2: Wrap it with PAGI::App::WrapPSGI",
      "Step 3: Verify REQUEST_METHOD is set correctly",
      "Step 4: Verify SCRIPT_NAME and PATH_INFO are set",
      "Step 5: Verify QUERY_STRING is set",
      "Step 6: Verify SERVER_NAME, SERVER_PORT, SERVER_PROTOCOL are set",
      "Step 7: Verify REMOTE_ADDR, REMOTE_PORT are set",
      "Step 8: Verify HTTP_* headers are set",
      "Step 9: Verify psgi.version, psgi.url_scheme, psgi.input, psgi.errors are set"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "PSGI streaming response (coderef body) works",
    "steps": [
      "Step 1: Create a PSGI app that returns coderef body for streaming",
      "Step 2: Wrap it with PAGI::App::WrapPSGI",
      "Step 3: Verify streaming response is converted to http.response.body events"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "CLI launcher starts server with --app option",
    "steps": [
      "Step 1: Run: pagi-server --app examples/01-hello-http/app.pl --port 5000",
      "Step 2: Verify server starts and listens on port 5000",
      "Step 3: Send a request and verify response"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "CLI launcher supports --host binding address",
    "steps": [
      "Step 1: Run: pagi-server --app app.pl --host 0.0.0.0 --port 5000",
      "Step 2: Verify server binds to all interfaces",
      "Step 3: Verify server is accessible from localhost"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "CLI launcher supports --ssl-cert and --ssl-key for HTTPS",
    "steps": [
      "Step 1: Generate test SSL certificate and key",
      "Step 2: Run: pagi-server --app app.pl --ssl-cert cert.pem --ssl-key key.pem",
      "Step 3: Verify HTTPS connection works",
      "Step 4: Verify scope.scheme is 'https'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "CLI launcher --quiet suppresses startup banner",
    "steps": [
      "Step 1: Run: pagi-server --app app.pl --port 5000 --quiet",
      "Step 2: Verify no startup banner is printed to stderr",
      "Step 3: Verify server still functions correctly"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "CLI launcher --help shows usage information",
    "steps": [
      "Step 1: Run: pagi-server --help",
      "Step 2: Verify usage information is displayed",
      "Step 3: Verify all options are documented"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "HTTP/1.0 clients work without chunked encoding",
    "steps": [
      "Step 1: Start the PAGI server",
      "Step 2: Send HTTP/1.0 request",
      "Step 3: Verify response uses Content-Length instead of chunked encoding",
      "Step 4: Verify connection closes after response"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "HEAD request returns headers without body",
    "steps": [
      "Step 1: Start the PAGI server with examples/01-hello-http/app.pl",
      "Step 2: Send HEAD request",
      "Step 3: Verify response status is 200",
      "Step 4: Verify Content-Type header is present",
      "Step 5: Verify response body is empty"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "HTTP pipelining handles multiple requests per connection",
    "steps": [
      "Step 1: Start the PAGI server",
      "Step 2: Send multiple requests on single TCP connection without waiting",
      "Step 3: Verify all responses are received in order",
      "Step 4: Verify connection remains open for keep-alive"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Expect: 100-continue is handled correctly",
    "steps": [
      "Step 1: Start the PAGI server",
      "Step 2: Send request with Expect: 100-continue header",
      "Step 3: Verify server sends 100 Continue response",
      "Step 4: Send request body after 100 Continue",
      "Step 5: Verify final response is received"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Malformed HTTP requests return 400 Bad Request",
    "steps": [
      "Step 1: Start the PAGI server",
      "Step 2: Send malformed HTTP request (invalid request line)",
      "Step 3: Verify response status is 400 Bad Request",
      "Step 4: Verify connection is closed"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Date header is added to responses",
    "steps": [
      "Step 1: Start the PAGI server with examples/01-hello-http/app.pl",
      "Step 2: Send a GET request",
      "Step 3: Verify Date header is present in response",
      "Step 4: Verify Date header format is RFC 7231 compliant"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Connection timeout prevents resource exhaustion",
    "steps": [
      "Step 1: Start the PAGI server with short timeout",
      "Step 2: Open connection but don't send request",
      "Step 3: Wait for timeout period",
      "Step 4: Verify connection is closed by server"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Max header size exceeded returns 431",
    "steps": [
      "Step 1: Start the PAGI server with small max_header_size",
      "Step 2: Send request with headers exceeding limit",
      "Step 3: Verify response status is 431 Request Header Fields Too Large"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Max body size exceeded returns 413",
    "steps": [
      "Step 1: Start the PAGI server with small max_body_size",
      "Step 2: Send POST request with body exceeding limit",
      "Step 3: Verify response status is 413 Payload Too Large"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Multiple Cookie headers are normalized into single header",
    "steps": [
      "Step 1: Start the PAGI server with test app that inspects headers",
      "Step 2: Send request with multiple Cookie headers",
      "Step 3: Verify scope.headers contains single Cookie header",
      "Step 4: Verify cookie values are joined with '; '"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Keep-alive connection is reused for multiple requests",
    "steps": [
      "Step 1: Start the PAGI server",
      "Step 2: Send request with Connection: keep-alive",
      "Step 3: Verify response contains Connection: keep-alive",
      "Step 4: Send second request on same connection",
      "Step 5: Verify second response is received"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Multi-worker mode runs multiple worker processes",
    "steps": [
      "Step 1: Start the PAGI server with --workers 4",
      "Step 2: Verify 4 worker processes are spawned",
      "Step 3: Send multiple concurrent requests",
      "Step 4: Verify requests are handled by different workers"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Worker crash triggers automatic restart",
    "steps": [
      "Step 1: Start the PAGI server with --workers 2",
      "Step 2: Kill one worker process",
      "Step 3: Verify parent spawns a replacement worker",
      "Step 4: Verify server continues handling requests"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Each worker runs its own lifespan startup",
    "steps": [
      "Step 1: Create app that logs worker PID during lifespan.startup",
      "Step 2: Start server with --workers 2",
      "Step 3: Verify lifespan.startup runs in each worker (different PIDs)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Graceful shutdown waits for all workers to finish",
    "steps": [
      "Step 1: Start the PAGI server with --workers 2",
      "Step 2: Start a long-running request",
      "Step 3: Send SIGTERM to parent process",
      "Step 4: Verify workers complete in-flight requests",
      "Step 5: Verify all workers run lifespan.shutdown",
      "Step 6: Verify server exits after all workers complete"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Server.pm new() constructor accepts all configuration options",
    "steps": [
      "Step 1: Create PAGI::Server with all options (app, host, port, ssl, extensions, on_error)",
      "Step 2: Verify server object is created",
      "Step 3: Verify port() method returns correct port",
      "Step 4: Verify is_running() returns false before listen()"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Server.pm listen() starts accepting connections",
    "steps": [
      "Step 1: Create PAGI::Server instance",
      "Step 2: Call listen() method",
      "Step 3: Verify listen() returns a Future",
      "Step 4: Verify is_running() returns true",
      "Step 5: Verify server accepts connections"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Server.pm shutdown() performs graceful shutdown",
    "steps": [
      "Step 1: Create and start PAGI::Server",
      "Step 2: Call shutdown() method",
      "Step 3: Verify shutdown() returns a Future",
      "Step 4: Verify lifespan.shutdown is emitted",
      "Step 5: Verify server stops accepting new connections",
      "Step 6: Verify is_running() returns false after shutdown completes"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Protocol::HTTP1 parses HTTP/1.1 requests correctly",
    "steps": [
      "Step 1: Call parse_request() with valid HTTP/1.1 request",
      "Step 2: Verify method, path, headers are extracted",
      "Step 3: Verify bytes_consumed is returned",
      "Step 4: Verify incomplete request returns undef"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Protocol::HTTP1 serializes responses correctly",
    "steps": [
      "Step 1: Call serialize_response_start() with status and headers",
      "Step 2: Verify valid HTTP/1.1 response line is generated",
      "Step 3: Verify headers are formatted correctly",
      "Step 4: Call serialize_response_body() and verify chunk formatting"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "send() after disconnect is a no-op per spec",
    "steps": [
      "Step 1: Start streaming response",
      "Step 2: Disconnect client mid-stream",
      "Step 3: Attempt to call send() from app",
      "Step 4: Verify send() does not throw error",
      "Step 5: Verify send() returns completed Future"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "receive() returns Future that completes when event available",
    "steps": [
      "Step 1: Start a long-running request",
      "Step 2: Call receive() before body arrives",
      "Step 3: Verify receive() returns a pending Future",
      "Step 4: Send request body",
      "Step 5: Verify Future resolves with http.request event"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Unsupported scope type causes app to throw exception",
    "steps": [
      "Step 1: Create app that only handles 'http' scope",
      "Step 2: Trigger a WebSocket upgrade request",
      "Step 3: Verify app throws 'Unsupported scope type' exception",
      "Step 4: Verify server handles the exception gracefully"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Middleware can wrap applications without mutating scope",
    "steps": [
      "Step 1: Create a middleware that adds custom key to scope",
      "Step 2: Wrap a PAGI app with the middleware",
      "Step 3: Verify wrapped app receives modified scope",
      "Step 4: Verify original scope is not mutated"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Access log writes request/response info",
    "steps": [
      "Step 1: Start server with access_log option",
      "Step 2: Send a request",
      "Step 3: Verify access log contains request method and path",
      "Step 4: Verify access log contains response status"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "All modules have POD documentation",
    "steps": [
      "Step 1: Check PAGI::Server.pm has POD with NAME, SYNOPSIS, DESCRIPTION",
      "Step 2: Check PAGI::Server::Connection.pm has POD",
      "Step 3: Check PAGI::Server::Protocol::HTTP1.pm has POD",
      "Step 4: Check all other public modules have POD",
      "Step 5: Verify SYNOPSIS examples are runnable"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Code follows modern Perl style with signatures",
    "steps": [
      "Step 1: Verify all modules use 'use experimental signatures'",
      "Step 2: Verify subroutines use signature syntax ($arg) not @_",
      "Step 3: Verify async/await syntax is used for async operations"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Test suite passes with prove -l t/",
    "steps": [
      "Step 1: Run: prove -l t/",
      "Step 2: Verify all tests pass",
      "Step 3: Verify no warnings or errors"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "dzil build succeeds",
    "steps": [
      "Step 1: Run: dzil build",
      "Step 2: Verify build completes without errors",
      "Step 3: Verify PAGI-Server-*.tar.gz is created"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "dzil test passes",
    "steps": [
      "Step 1: Run: dzil test",
      "Step 2: Verify all distribution tests pass"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "No circular dependencies between modules",
    "steps": [
      "Step 1: Analyze module dependencies",
      "Step 2: Verify no circular use/require chains",
      "Step 3: Verify clean module loading order"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Protocol parsing is isolated in Protocol::* modules",
    "steps": [
      "Step 1: Verify HTTP1.pm only does HTTP parsing, no I/O",
      "Step 2: Verify Connection.pm handles all I/O via IO::Async",
      "Step 3: Verify architecture allows adding HTTP2/HTTP3 modules"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Header names are lowercase per PAGI spec",
    "steps": [
      "Step 1: Send request with mixed-case headers",
      "Step 2: Verify scope.headers contains lowercase header names",
      "Step 3: Verify response headers use lowercase names"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Error messages are clear and helpful for app developers",
    "steps": [
      "Step 1: Trigger various error conditions",
      "Step 2: Verify error messages include context (what failed)",
      "Step 3: Verify stack traces are logged for debugging"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "WebSocket upgrade rejection returns HTTP 403",
    "steps": [
      "Step 1: Create an app that sends websocket.close before websocket.accept",
      "Step 2: Send WebSocket upgrade request",
      "Step 3: Verify server responds with HTTP 403 Forbidden",
      "Step 4: Verify connection is closed"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "SSE id and retry fields are transmitted correctly",
    "steps": [
      "Step 1: Create SSE app that sends id and retry fields",
      "Step 2: Connect with EventSource",
      "Step 3: Verify id: field appears in event stream",
      "Step 4: Verify retry: field appears in event stream"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Content-Length validation rejects mismatched body",
    "steps": [
      "Step 1: Start the PAGI server",
      "Step 2: Send request with Content-Length: 10 but only 5 bytes in body",
      "Step 3: Verify server handles the incomplete request appropriately"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Path decoding handles URL-encoded characters",
    "steps": [
      "Step 1: Send request to /path%20with%20spaces",
      "Step 2: Verify scope.path contains decoded '/path with spaces'",
      "Step 3: Verify scope.raw_path contains original '/path%20with%20spaces'"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "on_error callback is invoked for server errors",
    "steps": [
      "Step 1: Create server with on_error callback",
      "Step 2: Trigger an error condition",
      "Step 3: Verify on_error callback receives error details"
    ],
    "passes": false
  }
]
