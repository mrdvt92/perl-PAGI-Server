#!/usr/bin/env perl
use strict;
use warnings;
use experimental 'signatures';
use Getopt::Long;
use Pod::Usage;
use IO::Async::Loop;

use lib 'lib';
use PAGI::Server;

=head1 NAME

pagi-server - PAGI Reference Server CLI

=head1 SYNOPSIS

    pagi-server --app app.pl [options]

    Options:
        --app, -a       Path to .pl file returning PAGI app coderef (required)
        --host, -h      Bind address (default: 127.0.0.1)
        --port, -p      Bind port (default: 5000)
        --workers, -w   Number of worker processes (default: 1)
        --ssl-cert      Path to SSL certificate (enables HTTPS)
        --ssl-key       Path to SSL private key
        --access-log    Path to access log file (default: STDERR)
        --quiet, -q     Suppress startup banner
        --help          Show this help

=head1 EXAMPLES

    # Start with a simple app
    pagi-server --app examples/01-hello-http/app.pl --port 8080

    # Start with HTTPS
    pagi-server -a myapp.pl -p 3000 --ssl-cert cert.pem --ssl-key key.pem

=cut

my %opts = (
    host    => '127.0.0.1',
    port    => 5000,
    workers => 1,
);

GetOptions(
    'app|a=s'       => \$opts{app},
    'host|h=s'      => \$opts{host},
    'port|p=i'      => \$opts{port},
    'workers|w=i'   => \$opts{workers},
    'ssl-cert=s'    => \$opts{ssl_cert},
    'ssl-key=s'     => \$opts{ssl_key},
    'access-log=s'  => \$opts{access_log},
    'quiet|q'       => \$opts{quiet},
    'help'          => \$opts{help},
) or pod2usage(2);

pod2usage(1) if $opts{help};
pod2usage("--app is required") unless $opts{app};

# Validate app file exists
die "App file not found: $opts{app}\n" unless -f $opts{app};

# Validate SSL options
if ($opts{ssl_cert} || $opts{ssl_key}) {
    die "--ssl-cert and --ssl-key must be specified together\n"
        unless $opts{ssl_cert} && $opts{ssl_key};
    die "SSL cert not found: $opts{ssl_cert}\n" unless -f $opts{ssl_cert};
    die "SSL key not found: $opts{ssl_key}\n" unless -f $opts{ssl_key};
}

# Load the app - convert to absolute path for proper do() behavior
use File::Spec;
my $app_path = File::Spec->rel2abs($opts{app});
my $app = do $app_path;
die "Failed to load app: $@" if $@;
die "App file must return a coderef" unless ref $app eq 'CODE';

# Build server options
my %server_opts = (
    app   => $app,
    host  => $opts{host},
    port  => $opts{port},
    quiet => $opts{quiet} ? 1 : 0,
);

# Add SSL config if provided
if ($opts{ssl_cert} && $opts{ssl_key}) {
    $server_opts{ssl} = {
        cert_file => $opts{ssl_cert},
        key_file  => $opts{ssl_key},
    };
}

# Add access log if provided
if ($opts{access_log}) {
    open my $log_fh, '>>', $opts{access_log}
        or die "Cannot open access log $opts{access_log}: $!\n";
    $server_opts{access_log} = $log_fh;
}

# Create event loop and server
my $loop = IO::Async::Loop->new;

my $server = PAGI::Server->new(%server_opts);
$loop->add($server);

# Start listening with proper error handling
eval {
    $server->listen->get;
};
if ($@) {
    my $error = $@;
    # Clean up common IO::Async error messages
    if ($error =~ /Cannot bind\(\).*Address already in use/i) {
        die "Error: Port $opts{port} is already in use\n";
    }
    elsif ($error =~ /Cannot bind\(\).*Permission denied/i) {
        die "Error: Permission denied to bind to port $opts{port}\n";
    }
    elsif ($error =~ /Cannot bind\(\)/) {
        $error =~ s/\s+at\s+\S+\s+line\s+\d+.*//s;  # Strip stack trace
        die "Error: $error\n";
    }
    die "Error starting server: $error\n";
}

# Run the event loop
$loop->run;

__END__

=head1 AUTHOR

John Napiorkowski E<lt>jjnapiork@cpan.orgE<gt>

=head1 LICENSE

This software is licensed under the same terms as Perl itself.

=cut
