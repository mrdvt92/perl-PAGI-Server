Revision history for PAGI

## [Unreleased]

### Changed

- **BREAKING**: Renamed `$router->stash` to `$router->state` in PAGI::Endpoint::Router
- **BREAKING**: `$req->stash`, `$ws->stash`, `$sse->stash` now live in scope
  (`$scope->{'pagi.stash'}`) and are shared across all middleware, handlers,
  and subrouters processing the same request
- **BREAKING**: Removed `$req->set_stash()`, `$req->set()`, `$req->get()` methods
  - Just use `$req->stash->{key}` for all request-scoped data sharing
- **BREAKING**: Removed `$sse->set_stash()` method
- Removed automatic copying of router state into request stash
- **BREAKING**: Removed `on_startup` and `on_shutdown` from PAGI::Endpoint::Router
  - Use PAGI::Lifespan wrapper for lifecycle management instead
  - Routers are now freely composable without lifecycle concerns

### Added

- New `PAGI::Lifespan` module for explicit lifecycle management
  - Wraps any PAGI app with startup/shutdown callbacks
  - Injects app state into scope as `$scope->{'pagi.state'}`
- `state` accessor on PAGI::Request, PAGI::WebSocket, PAGI::SSE
  - Reads app state from scope (injected by PAGI::Lifespan)
  - Separate from `stash` (per-request data)
- `connection_state` accessor on PAGI::WebSocket, PAGI::SSE
  - Per-connection data storage (previously called `state`)
  - Renamed to avoid collision with new app-level `state` accessor
  - Use for connection-specific data like user info, subscriptions, etc.
- Standardized on `JSON::MaybeXS` for all JSON handling
  - Automatically uses fastest available backend (Cpanel::JSON::XS recommended)
  - Install `Cpanel::JSON::XS` for best performance

### Migration Guide

**Router state:**
```perl
# Before
$self->stash->{db} = DBI->connect(...);

# After
$self->state->{db} = DBI->connect(...);
```

**Accessing state in handlers:**
```perl
# Before (state was copied to request stash)
my $db = $req->stash->{db};

# After (access via $self)
my $db = $self->state->{db};
```

**Middleware data sharing:**
```perl
# Before
$req->set('user', $user);
my $user = $req->get('user');

# After (just use stash)
$req->stash->{user} = $user;
my $user = $req->stash->{user};
```

**WebSocket/SSE connection state:**
```perl
# Before
$ws->state->{user_id} = $user_id;
my $user_id = $ws->state->{user_id};

# After
$ws->connection_state->{user_id} = $user_id;
my $user_id = $ws->connection_state->{user_id};
```

### Important Notes

**Worker Isolation:** `$self->state` is per-worker. In multi-worker deployments,
each worker has isolated state. For shared state across workers or cluster nodes,
use external storage (Redis, database, etc.).

**Stash Flows Downstream:** `$req->stash` is shared across all middleware, handlers,
and subrouters for the same request. Middleware can set values that downstream
handlers will see.

**Lifecycle management (Router):**

Before (lifecycle in router):
```perl
package MyApp;
use parent 'PAGI::Endpoint::Router';

async sub on_startup {
    my ($self) = @_;
    $self->state->{db} = DBI->connect(...);
}

# app.pl
MyApp->to_app;
```

After (lifecycle via wrapper):
```perl
package MyApp;
use parent 'PAGI::Endpoint::Router';
# No on_startup/on_shutdown needed

# app.pl
use PAGI::Lifespan;
my $router = MyApp->new;

PAGI::Lifespan->wrap(
    $router->to_app,
    startup => async sub {
        my ($state) = @_;  # State hash injected into every request
        $state->{db} = DBI->connect(...);
        $state->{config} = { app_name => 'MyApp' };
    },
    shutdown => async sub {
        my ($state) = @_;
        $state->{db}->disconnect;
    },
);
```

Accessing state in handlers:
```perl
# Via request, websocket, or sse
my $db = $req->state->{db};
my $db = $ws->state->{db};
my $db = $sse->state->{db};
```
